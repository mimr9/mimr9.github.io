---
title: نصب قدم به قدم آرچ‌لینوکس با رمزگزاری
tags: لینوکس آرچ قفل رمز امنیت
uuid: b7cfec6-fa39-4c56-b707-882f69f01749
category: لینوکس
---

یک لپ‌تاپ لنووی x250 با هارددیسک SSD در اختیار دارم و تصمیم گرفتم که روی آن آرچ‌لینوکس نصب کنم. در ضمن می‌خواهم که کل دیسک رمزگزاری شده، پارتیشن‌ها با GPT و دیسک‌های lvm باشند. منبع همه‌ی موارد ویکی بی‌نظیر آرچ‌لینوکس است.


# ساختن فلش دیسک بوت‌شو
اول ایزوی آرچ را دانلود کردم و روی فلش کپی کردم. نکته‌ی جالب اینکه بدانید هر ایزویی که در یک ویرچوال ماشین و یا از یک سی‌دی یا دی‌وی‌دی بوت می‌شود لزوما از روی فلش دیسک بوت نمی‌شود. یک ایمیج برای اینکه از روی فلش و هارد دیسک بوت شود باید پارتیشن‌تیبل و پارتیشن‌ها را شبیه سازی بکند. بگذریم، فایل دانلودی را با ابزار قدرتمند `dd` روی فلش می‌ریزم:

~~~~
dd if=archlinux-2016.05.01-dual.iso of=/dev/mmcblk0 bs=4m
~~~~

> dd شوخی بردار نیست. آدرس اشتباه بدهیم هارد اشتباهی را نابود کرده‌ایم.


# آماده کردن هاردیسک
بعد از بوت از روی فلش دیسک اول می‌روم سراغ دیسک تا آنرا GPT کنیم که جایگزین امروزی MBR است.

~~~~
# fdisk -l # Print list of hard disks
# fdisk /dev/sda
# Command (m for help): g # Creates a GPT partition table
# Command (m for help): w # Save changes and exit
~~~~

با ابزار `fdisk` جدول پارتیشن را به GPT تغییر دادیم. الان هرپارتیشنی روی دیسک بوده باشد نابود شده است.


 حالا با ابزار `parted` پارتیشن بوت و یک پارتیشن خالی بزرگ می‌سازم:


~~~~
parted
(parted) print # List partitions
(parted) mkpart ESP ext4 1MiB 513MiB
(parted) set 1 boot on
(parted) mkpart ext4 513MiB 100%
~~~~

## ساخت پارتیشن رمزگزاری شده LUKS

با دستورات بالا اول پارتیشن کوچکی برای بوت ساختیم، بعد آنرا لیبل بوت زدیم و بعد هم در فضای باقی مانده یک دیسک بزرگ ساختیم. حالا نوبت رمزگذاری است. اینکار را با LUKS انجام می‌دهیم. توجه کنید که سناریوهای مختلفی برای اینکار وجود دارد. من تصمیم گرفتم که یک پارتیشن بوت معمولی بسازم و بعد در یک پارتیشن ثانویه با کمک LUKS یک پارتیشن رمزگزاری شده بوجود بیاورم. این مرحله را با کمک ابزار `cryptsetup` انجام می‌دهیم:

~~~~
cryptsetup luksFormat /dev/sda2
~~~~

دستور بالا از من یک پسورد می‌خواهد که دوبار وارد می‌کنم. حالا می‌توانم قفل این پارتیشن را باز کنم:

~~~~
cryptsetup open --type luks /dev/sda2 lvm
~~~~
 
این دستور پسورد را می‌پرسد و بعد در مسیر `/dev/mapper/lvm` پارتیشن قفل باز شده را در اختیار ما می‌گذارد. باید توجه داشت هرچند که همچنان پارتیشن اصلی در مسیر `/dev/sda2` وجود دارد اما محتوای آن رمزگزاری شده است و نامفهوم.


> نکته مهم: اگر روی دیسک از پیش داده‌های مهم وجود دارد باید ابتدا به روش صحیح نابود بشوند.

## پارتیشن‌بندی با LVM

حالا ما یک دیسک مجازی در مسیر بالا داریم که روی آن با `Logical Volume Management (LVM)` پارتیشن‌بندی انجام می‌دهیم. یک مقدمه کوتاه در مورد lvm. کاری که این روش مدیریت پارتیشن‌ها انجام می‌دهید اینست که وابستگی مستقیم پارتیشن فیزیکی را از پارتیشن نهایی از میان برمی‌دارد. یعنی مهم نیست که هاردیسک کجاست یا چند هاردیسک وجود دارد، ما همواره می‌توانیم که پارتیشن منطقی بسازیم که اجزای اصلی سازنده‌اش روی یک یا چند هاردیسک پخش شده باشد. در این روش به سادگی می‌توان اندازه پارتیشن را کم و زیاد کرد حتی هنگامی که سیستم در حال کار است. همچنین می‌توان فضای ذخیره‌سازی جدید به سیستم اضافه کرد و آنرا بین پارتیشن‌های مختلف تقسیم کرد.

پارتیشن‌بندی با lvm سه مرحله دارد. اولین مرحله ایجاد یک `Physical Volume (PV)` است. PVها قطعاتی هستند مثل قطعات بازی لگو که ما با آنها `Volume Group (VG)` می‌سازیم. VGها معادل یک هارددیسک مجازی هستند. تصور کنید که من با چند هاردیسک یک دیسک مجازی بزرگ بسازیم. هر هارددیسک من می‌شود یک PV که با آنها می‌توانم یک یا چند VG بسازم. به راحتی می‌شود به یک VG دیسک‌های جدید اضافه کرد.

اگر VG معادل هاردیسک باشد در مرحله بعدی به معادل یک پارتیشن معمولی نیاز داریم که به آن `Logical Volume (LV)` گفته می‌شود. LV فضای مورد نیازش را از VG برمی‌دارد و مثل یک پارتیشن معمولی است.

با توضیحات بالا می‌رویم سراغ ساختن پارتیشن‌ها. اول PV و بعد VG و بعد LVهای مورد نیاز:

~~~
# pvcreate /dev/mapper/lvm
# vgcreate X1 /dev/mapper/lvm
# lvcreate -L 8G X1 -n swap
# lvcreate -L 50G X1 -n root
# lvcreate -l 100%FREE X1 -n home
~~~

سطر اول دستورات بالا روی دیسک قفل‌باز شده (که خودش اینجا یک دیسک مجازی است چرا که پارتیشن اصلی در مسیر `/dev/sda2` قرار دارد.) یک PV می‌سازد. خط دوم روی آن PV یک VG بنام X1 می‌سازد. خط‌های بعدی هم روی آن VG پارتیشن‌ها را می‌سازند. خط آخر کل فضای باقی مانده را به یک پارتیشن بنام home می‌دهد. پس خلاصه کار می‌شود:

1. یک PV بساز
2. یک VG بساز
3. چند LV بساز (پارتیشن معمولی)


حالا نوبت فرمت کردن پارتیشن‌هاست. دقت کنید که همه مسیرها مجازی هستند (`/dev/mapper/X1-something`):

~~~
# mkfs.ext4 /dev/mapper/X1-root
# mkfs.ext4 /dev/mapper/X1-home
# mkswap /dev/mapper/X1-swap
~~~~

با وارد کردن دستور lvdisplay می‌تواند لیست پارتیشن‌های ساخته شده را دید. اگر دستور lvm را وارد کنید محیط اینتراکتیو می‌شود و می‌توانید همه دستورات مرتبط را با help ببینید. حالا هم پارتیشن‌ها را ماونت می‌کنم و می‌روم سراغ پارتیشن بوت:

~~~~
# mount /dev/mapper/X1-root /mnt
# mkdir /mnt/home
# mount /dev/mapper/X1-home /mnt/home
# swapon /dev/mapper/X1-swap
~~~~

حالا نوبت پارتیشن بوت است که باید روی یک درایو رمزگزاری نشده قرار داشته باشد که ما همان ابتدا ساختیم. آنرا هم آماده و ماونت می‌کنیم و می‌رویم سروقت نصب آرچ:

~~~~
# mkfs.ext2 /dev/sda1
# mkdir /mnt/boot
# mount /dev/sda1 /mnt/boot
~~~~

بعد بلافاصله می‌رویم سراغ تنظیمات اینترنت:

~~~~
# iw dev # Get a list of devices
# wifi-menu -o wlp3s0
~~~~

من اینترنت را از روتر وایرلس خانه‌ام می‌گیرم. خط دوم لیست مودم‌های وایرلس را می‌دهد و در خط سوم اسم مودم را که از دستور دوم بدست آورده‌ام وارد می‌کنم. در اینجا اگر همه‌چیز درست پیش برود دیالوگی نمایش داده می‌شود و می‌توان شبکه درست را انتخاب و پسورد آنرا وارد کرد. بعد باید اینترنت وصل شده باشد. حالا زمان سیستم را درست می‌کنیم:

~~~~
# timedatect set-ntp true
~~~~

# نصب بیس آرچ
حالا نوبت نصب بسته‌های بیس آرچ است، شامل base و base-devel:

~~~~
# pacstrap -i /mnt base base-devel
~~~~

دقت کنید که ما در مراحل قبلی پارتیشن‌هایمان را در مسیر `/mnt` ماونت کرده‌ایم. بعد از اتمام نصب باید fstab را ایجاد کنیم:

~~~~
# genfstab -U /mnt >> /mnt/etc/fstab
~~~~

در مرحله بعدی فایل تنظیمات شبکه را کپی می‌کنیم و به مسیر `/mnt` تغییر مسیر می‌دهیم و نصب را دنبال می‌کنیم:

~~~~
# cp /etc/netct/wlp3s0-HomeNet /mnt/etc/netctl/
# arch-chroot /mnt /bin/bash
~~~~

اول باید تنظیمات زبان را انجام دهیم. در فایل `/etc/locate.gen` خطوط مربوط به زبانهایی که می‌خواهیم را از کامنت خارج می‌کنیم و تنظیمات زبان را تولید می‌کنیم:

~~~~
# vi /etc/locale.gen # uncommet en_US.UTF-8 UTF-8 fa_IR UTF-8
# locale-gen
~~~~
فایل تنظیمات محلی را هم می‌سازیم و یکی از گزینه‌های انتخابی مرحله قبل را در اولین خط آن وارد می‌کنیم:

~~~~
# vi /etc/locate.conf # add LANG=en_US.UTF-8 or fa_IR
~~~~

حالا انتخاب ناحیه زمانی:

~~~~
# tzselect
# ln -s /usr/share/zoneinfo/Asia/Tehran /etc/localtime
~~~~

# تولید ایمج بوت

حالا وقت ساختن ایمیج بوت است به کمک `mkinitcpio`. اینجای کار باید تنظیمات را برای بوت صحیح از پارتیشن رمزگزاری شده اصلاح کنیم. فایل mkinitcpio.conf  را باز می‌کنیم و می‌رویم سراغ مهمترین بخش فایل بنام HOOKS:

~~~~
# vi /etc/mkinitcpio.conf # find HOOKS section

HOOKS="... encrypt lvm2 ... filesystems ..."

# mkinitcpio -p linux
~~~~

مقدار HOOKS را طوری تغییر می‌دهیم که دو مقدار encrypt و lvm2 قبل از filesystems و بعد از سایر مقادیر قرار بگیرند. دستور آخر فایل تنظیمات را می‌خواند و ایمیج بوت را در مسیر `/boot` می‌سازد.

## پارامترهای کرنل
برای اینکه کرنل بتواند پارتیشن رمزگزاری شده را بفهمد و پسورد آنرا بخواهد باید تنظیماتی به آن بدهیم. برای اینکار باید تصمیم بگیریم که کدام بارگزار را می‌خواهیم نصب کنیم چون هر کدام تنظیماتشان را جداگانه ذخیره می‌کنند. برای این لپ‌تاپ من تصمیم گرفتم Syslinux را نصب کنم. اول خود پکیج باید نصب شود:

~~~~
# pacman -S syslinux gptfdisk
~~~~

حالا باید پارامتر لازم برای اینکه کرنل پارتیشن ما را پیدا کند و بخواند را به فایل تنظیمات syslinux اضافه کنیم:

~~~~
# vi /boot/syslinux/syslinux.cfg
# Go to "LABEL arch" section and edit line with APPEND
~~~~

در این فایل باید منوی آرچ را پیدا کنیم که محتوای آن چیزی است شبیه به این:

~~~~
LABEL arch
   MENU ....
   LINUX ...
   APPEND root=/dev/sda3 rw
   INITRD ...
~~~~

سه نقطه‌ها را من گذاشته‌ام، برای ما مهم نیستند. خطی که باید تغییر کند خط APPEND است که ما آنرا با مقدار زیر جایگزین می‌کنیم:

~~~~
APPEND cryptdevice=UUID=<uuid of the /dev/sda2>:lvm root=/dev/mapper/X1-root rw
~~~~

مقدار uuid را برای `/dev/sda2` به کمک دستور `blkid` بدست می‌آید. حالا به کمک اسکریپتی که همراه با syslinux نصب شده (که جزو آرچ است نه آپ‌استریم) بوت لودر را نصب می‌کنیم:

~~~~
# syslinux-install_update -i -a -m
~~~~

حالا تنظیمات پیش از ریبوت کردن را انجام می‌دهیم:

~~~~
# vi /etc/hostname # pick up a name
# pacman -S iw wpa_supplicant dialog # installs it inside chroot environment
# passwd # pick up a password
~~~~

# ریبوت

حالا از chroot خارج می‌شویم و ریبوت می‌کنیم:

~~~
# exit # exit from chroot
# umount -R /mnt # unmount everything
# reboot
~~~~

بعد از حبس کردن نفسم و بوت شدن کامپیوتر تایید می‌کنم که دستورات بالا بدون نقص کار کردند. اول منوی بوت syslinux ظاهر شد و بعد از انتخاب بوت آرچ پسورد پارتیشن رمزگزاری شده ازم خواسته شد. بعد از وارد کردن اون سیستم بوت شد و لاگین آرچ ظاهر شد! هورا!

بعد از بوت وایرلس کار نمی‌کرد. حتما چیزی رو جا انداختم بهرحال با دو دستور ساده درست شد:

~~~~
# iw dev # to get name of the wireless card
# wifi-menu -o wlp3s0
~~~~
آپدیت: متوجه شدم که با هر بار ریبوت وایرلس خودکار وصل نمی‌شود و باید با دستور بالا وصل بشوم. برای رفع این مشکل با دستور netctl سرویسی برای راه‌اندازی خودکار وایرلس به systemd اضافه کردم که مشکل را حل کرد:

~~~~
# netctl list # get the name of connections
# netctl enable <connectionn name here>
~~~~
اگر در اسم فایل فاصله و کاما وجود دارد قبلشان یک بک‌اسلش اضافه کنید.


# گام بعدی
گام بعدی نصب gnome-shell روی لپ تاپ است که در مقاله‌ای دیگر می‌نویسم.

